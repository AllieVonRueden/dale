(module variant)

(import cstdio)
(import stdlib)

; Functional, but needs tidying and documentation.

(using-namespace std.macros

(def def-variant (macro extern (name instances)
  (def enumbuf (var auto (array-of 255 char)))
  (sprintf enumbuf "_Enum%s" (@:@ name token-str))
  (def enumnode (var auto \ (mnfv mc enumbuf)))

  (def lookupbuf (var auto (array-of 255 char)))
  (sprintf lookupbuf "_Lookup%s" (@:@ name token-str))
  (def lookupnode (var auto \ (mnfv mc lookupbuf)))

  (def cholder6 (var auto (p DNode) (nullptr DNode)))
  (def chlast6  (var auto (p DNode) (nullptr DNode)))
  (def current6 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current6))
    (def name2 (var auto (p DNode)
        (if (not (null (@:@ current6 list-node)))
            (@:@ current6 list-node)
            current6)))
    (def has-args (var auto bool (not (null (@:@ current6 list-node)))))
    (def args (var auto (p DNode)
        (if has-args
            (@:@ (@:@ (@:@ current6 list-node) next-node) list-node)
            (qq void))))
    (def mn (var auto (p DNode)
        (if has-args
            (qq def (uq name2) (struct extern ((type (uq enumnode)) (uql args))))
            (qq def (uq name2) (struct extern ((type (uq enumnode))))))))
    (setv current6 (@:@ current6 next-node))
    (if (null cholder6)
        (do (setv cholder6 mn)
            (setv chlast6 mn))
        (do (setf (:@ chlast6 next-node) mn)
            (setv chlast6 mn))))
  (def struct-defs (var auto (p DNode) (qq do (uql cholder6))))

  (def cholder (var auto (p DNode) (nullptr DNode)))
  (def chlast  (var auto (p DNode) (nullptr DNode)))
  (def current (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current))
    (def name2 (var auto (p DNode)
        (if (not (null (@:@ current list-node)))
            (@:@ current list-node)
            current)))
    (def has-args (var auto bool (not (null (@:@ current list-node)))))
    (def args (var auto (p DNode)
        (if has-args
            (@:@ (@:@ current list-node) next-node)
            (qq void))))

    (def inbetween (var auto (p DNode) (qq do 0)))
    (and has-args
      (do (def cholder5 (var auto (p DNode) (nullptr DNode)))
          (def chlast5  (var auto (p DNode) (nullptr DNode)))
          (def current5 (var auto (p DNode) (@:@ args list-node)))
          (while (not (null current5))
            (def aname (var auto (p DNode) (@:@ current5 list-node)))
            (def atype (var auto (p DNode) (@:@ aname next-node)))
            (def argset (var auto (p DNode)
              (qq setf (: myval (uq aname)) (uq aname))))
            (setv current5 (@:@ current5 next-node))
            (if (null cholder5)
                (do (setv cholder5 argset)
                    (setv chlast5 argset))
                (do (setf (:@ chlast5 next-node) argset)
                    (setv chlast5 argset))))
          (setv inbetween (qq do (uql cholder5)))))

    (def mn (var auto (p DNode)
        (qq def (uq name2) (fn extern (retval (uq name)) (uq args)
          (def myval (var auto (uq name2)))
          (setf (: myval type) ((uq enumnode) (uq name2)))
          (uq inbetween)
          (memcpy (cast retval (p void))
                  (cast (# myval) (p void))
                  (sizeof myval))
          (return)))))
    (setv current (@:@ current next-node))
    (if (null cholder)
        (do (setv cholder mn)
            (setv chlast mn))
        (do (setf (:@ chlast next-node) mn)
            (setv chlast mn))))
  (def mcholder (var auto (p DNode) (qq do (uql cholder))))

  (def cholder2 (var auto (p DNode) (nullptr DNode)))
  (def chlast2  (var auto (p DNode) (nullptr DNode)))
  (def current2 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current2))
    (def name (var auto (p DNode)
        (if (not (null (@:@ current2 list-node)))
            (@:@ current2 list-node)
            current2)))
    (def nn (var auto (p DNode) (copy-qstr mc name false)))
    (def mn2 (var auto (p DNode)
        (qq (= 0 (strcmp str (uq nn)))
            ((uq enumnode) (uq name)))))
    (setv current2 (@:@ current2 next-node))
    (if (null cholder2)
        (do (setv cholder2 mn2)
            (setv chlast2 mn2))
        (do (setf (:@ chlast2 next-node) mn2)
            (setv chlast2 mn2))))
  (setf (:@ chlast2 next-node)
    (qq true (cast -1 (uq enumnode))))

  (def mcholder2 (var auto (p DNode) (qq do
    (def _Convert (fn intern (uq enumnode) ((str (p (const char))))
      (def res (var auto \ (cond (uql cholder2))))
      res)))))
  (def lc (var auto \ (mnfv mc (list-count instances))))

  (def cholder3 (var auto (p DNode) (nullptr DNode)))
  (def chlast3  (var auto (p DNode) (nullptr DNode)))
  (def current3 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current3))
    (def name (var auto (p DNode)
        (if (not (null (@:@ current3 list-node)))
            (@:@ current3 list-node)
            current3)))
    (setv current3 (@:@ current3 next-node))
    (setf (:@ name next-node) (nullptr DNode))
    (if (null cholder3)
        (do (setv cholder3 name)
            (setv chlast3 name))
        (do (setf (:@ chlast3 next-node) name)
            (setv chlast3 name))))
  (def cholder4 (var auto (p DNode) (qq (uql cholder3))))
  (def choldert (var auto (p DNode) (nullptr DNode)))
  (def chlastt  (var auto (p DNode) (nullptr DNode)))
  (def currentt (var auto (p DNode) (@:@ instances list-node)))
  (def num (var auto int 0))
  (while (not (null currentt))
    (def name (var auto (p DNode)
        (if (not (null (@:@ currentt list-node)))
            (@:@ currentt list-node)
            currentt)))
    (def cnode (var auto (p DNode) (mnfv mc num)))
    (def mnode (var auto (p DNode)
        (qq do (setf ($ sizes (uq cnode)) (sizeof (uq name)))
               (setf ($ alignments (uq cnode)) (alignmentof (uq
               name))))))
    (setv currentt (@:@ currentt next-node))
    (setf (:@ mnode next-node) (nullptr DNode))
    (incv num)
    (if (null choldert)
        (do (setv choldert mnode)
            (setv chlastt mnode))
        (do (setf (:@ chlastt next-node) mnode)
            (setv chlastt mnode))))
  (def choldertt (var auto (p DNode) (qq do (uql choldert))))
  (qq do
    (def (uq enumnode) (enum extern int (uq cholder4)))
    (uq struct-defs)

    (def mm
      (macro intern (void)
        (def sizes (var auto (array-of (uq lc) size)))
        (def alignments (var auto (array-of (uq lc) size)))
        (uq choldertt)
        (def maxsize (var auto size 0))
        (def maxalignment (var auto size 0))
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (> (@$ sizes i) maxsize)
            (setv maxsize (@$ sizes i)))
          (and (> (@$ alignments i) maxalignment)
            (setv maxalignment (@$ alignments i))))
        ; todo: fix alignmentof.
        (setv maxalignment (sizeof double))
        (def remsize (var auto size (- maxsize (sizeof (uq enumnode)))))
        (setv remsize (+ remsize (% maxsize maxalignment)))
        (def remsizen (var auto (p DNode) (mnfv mc (cast remsize int))))
        (qq def (uq name)
          (struct extern ((type (uq enumnode))
                          (_unused (array-of (uq (uq remsizen)) uint8)))))))
    (mm)

    (uq mcholder)
    (uq mcholder2)
    (def case (macro extern ((object (uq name)) ...)
      (def found (var auto (array-of (uq lc) int)))
      (memset (cast found (p void)) 0 (uq lc))

        (for (i \ 0) (< i (uq lc)) (incv i)
          (setf ($ found i) 0))

      (def otherwise (var auto bool false))

      (def arg-count (var auto \ (arg-count mc)))
      (setv arg-count (- arg-count 1))
      (def arglist (var auto va-list))
      (va-start (cast (# arglist) (p void)))
      (def forms (var auto \ (std.macros.get-varargs-list mc arg-count (# arglist))))
      (va-end (cast (# arglist) (p void)))

      (def holder (var auto (p DNode) (nullptr DNode)))
      (def current (var auto (p DNode) (nullptr DNode)))
      (while (not (null forms))
        (def first (var auto \ (@:@ forms list-node)))
        (def second (var auto \ (@:@ first next-node)))

        (and (not (= 0 (strcmp (@:@ first token-str) "true")))
          (do (def ev (var auto \ (_Convert (@:@ first token-str))))
              (if (= (cast ev int) -1)
                  (do (report-error mc first "invalid variant type")
                      (return (nullptr DNode)))
                  (setf ($ found ev) 1))))

        (def real (var auto \
          (cond ((and (not (null (@:@ first token-str)))
                      (= 0 (strcmp (@:@ first token-str) "true")))
                 (std.macros.qq true (uq (uq second))))
                ((null (@:@ forms next-node))
                 (std.macros.qq true
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second)))))
                (true
                 (std.macros.qq (= (@: (uq (uq object)) type)
                                   ((uq enumnode) (uq (uq first))))
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second))))))))
        (and (= 0 (strcmp (@:@ first token-str) "true"))
          (setv otherwise true))
        (if (null current)
            (do (setv holder real)
                (setv current real))
            (do (setf (:@ current next-node) real)
                (setv current real)))
        (setv forms (@:@ forms next-node)))
      (and (not otherwise)
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (= 0 (@$ found i))
            (do (report-error mc object "case is non-exhaustive")
                (return (nullptr DNode))))))
      (def x (var auto \ (std.macros.qq do (cond (uq (uql holder))))))
      (return x))))))
)
