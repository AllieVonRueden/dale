#|
@module variant

Provides `def-variant`, which allows for defining variants, also known
as sum types or tagged unions.  Variant definition introduces the
following bindings:

   * a struct type for the variant;
   * a struct type for each of the variant's potential types;
   * constructors for each of the potential types, which take as their
     arguments the members for that potential type in definition
     order (if any);
   * a `case` form, which allows for executing a statement based on
     the underlying type of a particular variant.

For example:

        (def-variant Direction (North South East West))

        (def main (fn extern-c int (void)
          (let ((direction Direction (North)))
            (case direction
              (North (printf "Direction is north\n"))
              (true  (printf "Direction is not north\n"))))
          0))

yields:

        Direction is north

With parameters for the potential types:

        (def-variant Number ((Int    ((a int)))
                             (Float  ((a float)))
                             (Double ((a double)))))

        (def main (fn extern-c int (void)
          (let ((ni Number (Int 1))
                (nf Number (Float 2.0))
                (nd Number (Double (cast 3.0 double)))
                (na (array-of 3 Number) (array ni nf nd)))
            (for (i \ 0) (< i 3) (incv i)
              (let ((nc Number (@$ na i)))
                (case nc
                  (Int    (printf "Number is int (%d)\n"    (@:@ nc a)))
                  (Float  (printf "Number is float (%f)\n"  (@:@ nc a)))
                  (Double (printf "Number is double (%f)\n" (@:@ nc a)))))))
          0))

yields:

	Number is int (1)
	Number is float (2.000000)
	Number is double (3.000000)

|#
(module variant (attr cto))

(import cstdio)
(import stdlib)

(using-namespace std.macros

(def prefix-token-node (fn extern (p DNode) ((mc (p MContext))
                                             (node (p DNode)))
  (def buf (var auto (array-of 255 char)))
  (sprintf buf "_%s" (@:@ node token-str))
  (return (mnfv mc buf))))

(def def-variant (macro extern (name instances)
  (def enumbuf (var auto (array-of 255 char)))
  (sprintf enumbuf "_Enum%s" (@:@ name token-str))
  (def enumnode (var auto \ (mnfv mc enumbuf)))

  (def lookupbuf (var auto (array-of 255 char)))
  (sprintf lookupbuf "_Lookup%s" (@:@ name token-str))
  (def lookupnode (var auto \ (mnfv mc lookupbuf)))
  (def cholder6 (var auto (p DNode) (nullptr DNode)))
  (def chlast6  (var auto (p DNode) (nullptr DNode)))
  (def current6 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current6))
    (def name2 (var auto (p DNode)
        (if (not (null (@:@ current6 list-node)))
            (@:@ current6 list-node)
            current6)))
    (def has-args (var auto bool (not (null (@:@ current6 list-node)))))
    (def args (var auto (p DNode)
        (if has-args
            (@:@ (@:@ (@:@ current6 list-node) next-node) list-node)
            (qq void))))
    (def mn (var auto (p DNode)
        (if has-args
            (qq def (uq name2) (struct extern ((type (uq enumnode)) (uql args))))
            (qq def (uq name2) (struct extern ((type (uq enumnode))))))))
    (setv current6 (@:@ current6 next-node))
    (if (null cholder6)
        (do (setv cholder6 mn)
            (setv chlast6 mn))
        (do (setf (:@ chlast6 next-node) mn)
            (setv chlast6 mn))))
  (def struct-defs (var auto (p DNode) (qq do (uql cholder6))))
  (def cholder (var auto (p DNode) (nullptr DNode)))
  (def chlast  (var auto (p DNode) (nullptr DNode)))
  (def current (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current))
    (def name2 (var auto (p DNode)
        (if (not (null (@:@ current list-node)))
            (@:@ current list-node)
            current)))
    (def has-args (var auto bool (not (null (@:@ current list-node)))))
    (def args (var auto (p DNode)
        (if has-args
            (@:@ (@:@ current list-node) next-node)
            (qq void))))
    (def inbetween (var auto (p DNode) (qq do 0)))
    (and has-args
      (do (def cholder5 (var auto (p DNode) (nullptr DNode)))
          (def chlast5  (var auto (p DNode) (nullptr DNode)))
          (def current5 (var auto (p DNode) (@:@ args list-node)))
          (while (not (null current5))
            (def aname (var auto (p DNode) (@:@ current5 list-node)))
            (and (null aname)
              (do (report-error mc current5 "expected list for variant member")
                  (return (nullptr DNode))))
            (def atype (var auto (p DNode) (@:@ aname next-node)))
            (and (null atype)
              (do (report-error mc current5 "expected type for variant member")
                  (return (nullptr DNode))))
            (def argset (var auto (p DNode)
              (qq setf (: myval (uq aname)) (uq aname))))
            (setv current5 (@:@ current5 next-node))
            (if (null cholder5)
                (do (setv cholder5 argset)
                    (setv chlast5 argset))
                (do (setf (:@ chlast5 next-node) argset)
                    (setv chlast5 argset))))
          (setv inbetween (qq do (uql cholder5)))))

    (def name3 (var auto (p DNode) (prefix-token-node mc name2)))
    (def mn (var auto (p DNode)
        (qq def (uq name2) (fn extern (retval (uq name)) (uq args)
          (def myval (var auto (uq name2)))
          (setf (: myval type) (uq name3))
          (uq inbetween)
          (memcpy (cast retval (p void))
                  (cast (# myval) (p void))
                  (sizeof myval))
          (return)))))
    (setv current (@:@ current next-node))
    (if (null cholder)
        (do (setv cholder mn)
            (setv chlast mn))
        (do (setf (:@ chlast next-node) mn)
            (setv chlast mn))))
  (def mcholder (var auto (p DNode) (qq do (uql cholder))))
  (def cholder2 (var auto (p DNode) (nullptr DNode)))
  (def chlast2  (var auto (p DNode) (nullptr DNode)))
  (def current2 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current2))
    (def name (var auto (p DNode)
        (if (not (null (@:@ current2 list-node)))
            (@:@ current2 list-node)
            current2)))
    (def nn (var auto (p DNode) (std.macros.copy-qstr mc name false)))
    (setv name (prefix-token-node mc name))
    (def mn2 (var auto (p DNode)
        (qq (= 0 (strcmp str (uq nn)))
            (uq name))))
    (setv current2 (@:@ current2 next-node))
    (if (null cholder2)
        (do (setv cholder2 mn2)
            (setv chlast2 mn2))
        (do (setf (:@ chlast2 next-node) mn2)
            (setv chlast2 mn2))))
  (setf (:@ chlast2 next-node)
    (qq true (cast -1 (const (uq enumnode)))))

  (def mcholder2 (var auto (p DNode) (qq do
    (def _Convert (fn intern (uq enumnode) ((str (p (const char))))
      (def res (var auto \ (cond (uql cholder2))))
      res)))))
  (def lc (var auto \ (mnfv mc (list-count instances))))

  (def cholder3 (var auto (p DNode) (nullptr DNode)))
  (def chlast3  (var auto (p DNode) (nullptr DNode)))
  (def current3 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current3))
    (def name (var auto (p DNode)
        (if (not (null (@:@ current3 list-node)))
            (@:@ current3 list-node)
            current3)))
    (setv name (prefix-token-node mc name))
    (setv current3 (@:@ current3 next-node))
    (setf (:@ name next-node) (nullptr DNode))
    (if (null cholder3)
        (do (setv cholder3 name)
            (setv chlast3 name))
        (do (setf (:@ chlast3 next-node) name)
            (setv chlast3 name))))
  (def cholder4 (var auto (p DNode) (qq (uql cholder3))))
  (def choldert (var auto (p DNode) (nullptr DNode)))
  (def chlastt  (var auto (p DNode) (nullptr DNode)))
  (def currentt (var auto (p DNode) (@:@ instances list-node)))
  (def num (var auto int 0))
  (while (not (null currentt))
    (def name (var auto (p DNode)
        (if (not (null (@:@ currentt list-node)))
            (@:@ currentt list-node)
            currentt)))
    (def cnode (var auto (p DNode) (mnfv mc num)))
    (def mnode (var auto (p DNode)
        (qq do (setf ($ sizes (uq cnode)) (sizeof (uq name)))
               (setf ($ alignments (uq cnode)) (alignmentof (uq
               name))))))
    (setv currentt (@:@ currentt next-node))
    (setf (:@ mnode next-node) (nullptr DNode))
    (incv num)
    (if (null choldert)
        (do (setv choldert mnode)
            (setv chlastt mnode))
        (do (setf (:@ chlastt next-node) mnode)
            (setv chlastt mnode))))
  (def choldertt (var auto (p DNode) (qq do (uql choldert))))
  (qq do
    (def (uq enumnode) (enum extern int (uq cholder4)))
    (uq struct-defs)

    (def mm
      (macro intern (void)
        (def sizes (var auto (array-of (uq lc) size)))
        (def alignments (var auto (array-of (uq lc) size)))
        (uq choldertt)
        (def maxsize (var auto size 0))
        (def maxalignment (var auto size 0))
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (> (@$ sizes i) maxsize)
            (setv maxsize (@$ sizes i)))
          (and (> (@$ alignments i) maxalignment)
            (setv maxalignment (@$ alignments i))))
        (def remsize (var auto size (- maxsize (sizeof (uq enumnode)))))
        (setv remsize (+ remsize (% maxsize maxalignment)))
        (def remsizen (var auto (p DNode) (std.macros.mnfv mc (cast remsize int))))
        (std.macros.qq def (uq name)
          (struct extern ((type (uq enumnode))
                          (_unused (array-of (uq (uq remsizen)) uint8)))))))
    (mm)

    (uq mcholder)
    (uq mcholder2)
    (def case (macro extern ((object (uq name)) ...)
      (and (null (@:@ object token-str))
        (do (report-error mc object "case expression must be variable name")
            (return (nullptr DNode))))

      (def found (var auto (array-of (uq lc) int)))
      (memset (cast found (p void)) 0 (uq lc))

        (for (i \ 0) (< i (uq lc)) (incv i)
          (setf ($ found i) 0))

      (def otherwise (var auto bool false))

      (def arg-count (var auto \ (arg-count mc)))
      (setv arg-count (- arg-count 1))
      (def arglist (var auto va-list))
      (va-start (cast (# arglist) (p void)))
      (def forms (var auto \ (std.macros.get-varargs-list mc arg-count (# arglist))))
      (va-end (cast (# arglist) (p void)))

      (def holder (var auto (p DNode) (nullptr DNode)))
      (def current (var auto (p DNode) (nullptr DNode)))
      (while (not (null forms))
        (def first (var auto \ (@:@ forms list-node)))
        (def ffirst (var auto \ (prefix-token-node mc first)))
        (def second (var auto \ (@:@ first next-node)))

        (and (not (= 0 (strcmp (@:@ first token-str) "true")))
          (do (def ev (var auto \ (_Convert (@:@ first token-str))))
              (if (= (cast ev int) -1)
                  (do (report-error mc first "invalid variant type")
                      (return (nullptr DNode)))
                  (setf ($ found ev) 1))))

        (def real (var auto \
          (cond ((and (not (null (@:@ first token-str)))
                      (= 0 (strcmp (@:@ first token-str) "true")))
                 (std.macros.qq true (uq (uq second))))
                ((null (@:@ forms next-node))
                 (std.macros.qq true
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second)))))
                (true
                 (std.macros.qq (= (@: (uq (uq object)) type)
                                   (uq (uq ffirst)))
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second))))))))
        (and (= 0 (strcmp (@:@ first token-str) "true"))
          (setv otherwise true))
        (if (null current)
            (do (setv holder real)
                (setv current real))
            (do (setf (:@ current next-node) real)
                (setv current real)))
        (setv forms (@:@ forms next-node)))
      (and (not otherwise)
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (= 0 (@$ found i))
            (do (report-error mc object "case is non-exhaustive")
                (return (nullptr DNode))))))
      (def x (var auto \ (std.macros.qq do (cond (uq (uql holder))))))
      (return x))))))
)
