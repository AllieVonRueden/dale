#|
@module variant

Provides `def-variant`, which allows for defining variants, also known
as sum types or tagged unions.  Variant definition introduces the
following bindings:

   * a struct type for the variant;
   * a struct type for each of the variant's potential types;
   * constructors for each of the potential types, which take as their
     arguments the members for that potential type in definition
     order (if any);
   * a `case` form, which allows for executing a statement based on
     the underlying type of a particular variant.

For example:

        (def-variant Direction (North South East West))

        (def main (fn extern-c int (void)
          (let ((direction Direction (North)))
            (case direction
              (North (printf "Direction is north\n"))
              (true  (printf "Direction is not north\n"))))
          0))

yields:

        Direction is north

With parameters for the potential types:

        (def-variant Number ((Int    ((a int)))
                             (Float  ((a float)))
                             (Double ((a double)))))

        (def main (fn extern-c int (void)
          (let ((ni Number (Int 1))
                (nf Number (Float 2.0))
                (nd Number (Double (cast 3.0 double)))
                (na (array-of 3 Number) (array ni nf nd)))
            (for (i \ 0) (< i 3) (incv i)
              (let ((nc Number (@$ na i)))
                (case nc
                  (Int    (printf "Number is int (%d)\n"    (@:@ nc a)))
                  (Float  (printf "Number is float (%f)\n"  (@:@ nc a)))
                  (Double (printf "Number is double (%f)\n" (@:@ nc a)))))))
          0))

yields:

	Number is int (1)
	Number is float (2.000000)
	Number is double (3.000000)

|#
(module variant (attr cto))

(import cstdio)
(import stdlib)

(using-namespace std.macros

(def prefix-token-node (fn extern (p DNode) ((mc (p MContext))
                                             (prefix (p (const char)))
                                             (node (p DNode)))
  (def buf (var auto (array-of 255 char)))
  (and (null (@:@ node token-str))
    (return (nullptr DNode)))
  (sprintf buf "%s%s" prefix (@:@ node token-str))
  (return (mnfv mc buf))))

(def create-struct-defs (fn intern (p DNode) ((mc (p MContext))
                                              (enumnode (p DNode))
                                              (instances (p DNode)))
  (let ((holder  \ (nullptr DNode))
        (last    \ (nullptr DNode))
        (current \ (@:@ instances list-node)))
    (while (not (null current))
      (let ((has-args \ (not (null (@:@ current list-node))))
            (name     \ (if has-args (@:@ current list-node) current))
            (args     \ (if has-args
                            (@:' current list-node next-node list-node)
                            (qq void)))
            (struct-def \ (if has-args
                              (qq def (uq name)
                                (struct extern ((type (uq enumnode))
                                                (uql args))))
                              (qq def (uq name)
                                (struct extern ((type (uq enumnode))))))))
        (setv current (@:@ current next-node))
        (if (null holder)
            (setv holder struct-def)
            (setf (:@ last next-node) struct-def))
        (setv last struct-def)))
    (return (qq do (uql holder))))))

(def create-constructors (fn intern (p DNode) ((mc (p MContext))
                                               (name (p DNode))
                                               (instances (p DNode)))
  (def holder (var auto (p DNode) (nullptr DNode)))
  (def last  (var auto (p DNode) (nullptr DNode)))
  (def current (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current))
    (def name2 (var auto (p DNode)
        (if (not (null (@:@ current list-node)))
            (@:@ current list-node)
            current)))
    (def has-args (var auto bool (not (null (@:@ current list-node)))))
    (def args (var auto (p DNode)
        (if has-args
            (@:' current list-node next-node)
            (qq void))))
    (def inbetween (var auto (p DNode) (qq do 0)))
    (and has-args
      (do (def holder5 (var auto (p DNode) (nullptr DNode)))
          (def last5  (var auto (p DNode) (nullptr DNode)))
          (def current5 (var auto (p DNode) (@:@ args list-node)))
          (while (not (null current5))
            (def aname (var auto (p DNode) (@:@ current5 list-node)))
            (and (null aname)
              (do (report-error mc current5 "expected list for variant member")
                  (return (nullptr DNode))))
            (def atype (var auto (p DNode) (@:@ aname next-node)))
            (and (null atype)
              (do (report-error mc current5 "expected type for variant member")
                  (return (nullptr DNode))))
            (def argset (var auto (p DNode)
              (qq setf (: myval (uq aname)) (uq aname))))
            (setv current5 (@:@ current5 next-node))
            (if (null holder5)
                (do (setv holder5 argset)
                    (setv last5 argset))
                (do (setf (:@ last5 next-node) argset)
                    (setv last5 argset))))
          (setv inbetween (qq do (uql holder5)))))

    (def name3 (var auto (p DNode) (prefix-token-node mc "_" name2)))
    (def mn (var auto (p DNode)
        (qq def (uq name2) (fn extern (retval (uq name)) (uq args)
          (def myval (var auto (uq name2)))
          (setf (: myval type) (uq name3))
          (uq inbetween)
          (memcpy (cast retval (p void))
                  (cast (# myval) (p void))
                  (sizeof myval))
          (return)))))
    (setv current (@:@ current next-node))
    (if (null holder)
        (do (setv holder mn)
            (setv last mn))
        (do (setf (:@ last next-node) mn)
            (setv last mn))))
  (def mholder (var auto (p DNode) (qq do (uql holder))))
  (return mholder)))

(def create-convert-fn (fn intern (p DNode) ((mc (p MContext))
                                             (enumnode (p DNode))
                                             (instances (p DNode)))
  (def cholder2 (var auto (p DNode) (nullptr DNode)))
  (def chlast2  (var auto (p DNode) (nullptr DNode)))
  (def current2 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current2))
    (def name (var auto (p DNode)
        (if (not (null (@:@ current2 list-node)))
            (@:@ current2 list-node)
            current2)))
    (def nn (var auto (p DNode) (std.macros.copy-qstr mc name false)))
    (setv name (prefix-token-node mc "_" name))
    (def mn2 (var auto (p DNode)
        (qq (= 0 (strcmp str (uq nn)))
            (uq name))))
    (setv current2 (@:@ current2 next-node))
    (if (null cholder2)
        (do (setv cholder2 mn2)
            (setv chlast2 mn2))
        (do (setf (:@ chlast2 next-node) mn2)
            (setv chlast2 mn2))))
  (setf (:@ chlast2 next-node)
    (qq true (cast -1 (const (uq enumnode)))))

  (def mcholder2 (var auto (p DNode) (qq do
    (def _Convert (fn intern (uq enumnode) ((str (p (const char))))
      (def res (var auto \ (cond (uql cholder2))))
      res)))))
  (return mcholder2)))

(def create-enum-elements (fn intern (p DNode) ((mc (p MContext))
                                                (instances (p DNode)))
  (def cholder3 (var auto (p DNode) (nullptr DNode)))
  (def chlast3  (var auto (p DNode) (nullptr DNode)))
  (def current3 (var auto (p DNode) (@:@ instances list-node)))
  (while (not (null current3))
    (def name (var auto (p DNode)
        (if (not (null (@:@ current3 list-node)))
            (@:@ current3 list-node)
            current3)))
    (setv name (prefix-token-node mc "_" name))
    (setv current3 (@:@ current3 next-node))
    (setf (:@ name next-node) (nullptr DNode))
    (if (null cholder3)
        (do (setv cholder3 name)
            (setv chlast3 name))
        (do (setf (:@ chlast3 next-node) name)
            (setv chlast3 name))))
  (return (qq (uql cholder3)))))

(def create-sizes-and-alignments (fn intern (p DNode) ((mc (p MContext))
                                                       (instances (p
                                                       DNode)))
  (def choldert (var auto (p DNode) (nullptr DNode)))
  (def chlastt  (var auto (p DNode) (nullptr DNode)))
  (def currentt (var auto (p DNode) (@:@ instances list-node)))
  (def num (var auto int 0))
  (while (not (null currentt))
    (def name (var auto (p DNode)
        (if (not (null (@:@ currentt list-node)))
            (@:@ currentt list-node)
            currentt)))
    (def cnode (var auto (p DNode) (mnfv mc num)))
    (def mnode (var auto (p DNode)
        (qq do (setf ($ sizes (uq cnode)) (sizeof (uq name)))
               (setf ($ alignments (uq cnode)) (alignmentof (uq
               name))))))
    (setv currentt (@:@ currentt next-node))
    (setf (:@ mnode next-node) (nullptr DNode))
    (incv num)
    (if (null choldert)
        (do (setv choldert mnode)
            (setv chlastt mnode))
        (do (setf (:@ chlastt next-node) mnode)
            (setv chlastt mnode))))
  (def choldertt (var auto (p DNode) (qq do (uql choldert))))
  (return choldertt)))

#|
@macro def-variant

@param name         The name of the new variant.
@param instances    The type definitions for the variant.
|#
(def def-variant (macro extern (name instances)
  (def enumnode (var auto \ (prefix-token-node mc "_Enum" name)))
  (and (null enumnode)
    (do (report-error mc name "atom required for variant name")
        (return (nullptr DNode))))

  (def lookupnode (var auto \ (prefix-token-node mc "_Lookup" name)))

  (def struct-defs (var auto (p DNode)
                             (create-struct-defs mc enumnode instances)))
  (def constructors (var auto (p DNode)
                              (create-constructors mc name instances)))

  (def convert-fn (var auto (p DNode)
                            (create-convert-fn mc enumnode instances)))
  (def lc (var auto \ (mnfv mc (list-count instances))))

  (def enum-elements (var auto (p DNode) (create-enum-elements mc
                                            instances)))

  (def sizes-and-alignments
    (var auto (p DNode) (create-sizes-and-alignments
                            mc instances)))

  (qq do
    (def (uq enumnode) (enum extern int (uq enum-elements)))
    (uq struct-defs)

    (def mm
      (macro intern (void)
        (def sizes (var auto (array-of (uq lc) size)))
        (def alignments (var auto (array-of (uq lc) size)))
        (uq sizes-and-alignments)
        (def maxsize (var auto size 0))
        (def maxalignment (var auto size 0))
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (> (@$ sizes i) maxsize)
            (setv maxsize (@$ sizes i)))
          (and (> (@$ alignments i) maxalignment)
            (setv maxalignment (@$ alignments i))))
        (def remsize (var auto size (- maxsize (sizeof (uq enumnode)))))
        (setv remsize (+ remsize (% maxsize maxalignment)))
        (def remsizen (var auto (p DNode) (std.macros.mnfv mc (cast remsize int))))
        (std.macros.qq def (uq name)
          (struct extern ((type (uq enumnode))
                          (_unused (array-of (uq (uq remsizen)) uint8)))))))
    (mm)

    (uq constructors)
    (uq convert-fn)
    (def case (macro extern ((object (uq name)) ...)
      (and (null (@:@ object token-str))
        (do (report-error mc object "case expression must be variable name")
            (return (nullptr DNode))))

      (def found (var auto (array-of (uq lc) int)))
      (memset (cast found (p void)) 0 (uq lc))

        (for (i \ 0) (< i (uq lc)) (incv i)
          (setf ($ found i) 0))

      (def otherwise (var auto bool false))

      (def arg-count (var auto \ (arg-count mc)))
      (setv arg-count (- arg-count 1))
      (def arglist (var auto va-list))
      (va-start (cast (# arglist) (p void)))
      (def forms (var auto \ (std.macros.get-varargs-list mc arg-count (# arglist))))
      (va-end (cast (# arglist) (p void)))

      (def holder (var auto (p DNode) (nullptr DNode)))
      (def current (var auto (p DNode) (nullptr DNode)))
      (while (not (null forms))
        (def first (var auto \ (@:@ forms list-node)))
        (def ffirst (var auto \ (prefix-token-node mc "_" first)))
        (def second (var auto \ (@:@ first next-node)))

        (and (not (= 0 (strcmp (@:@ first token-str) "true")))
          (do (def ev (var auto \ (_Convert (@:@ first token-str))))
              (if (= (cast ev int) -1)
                  (do (report-error mc first "invalid variant type")
                      (return (nullptr DNode)))
                  (setf ($ found ev) 1))))

        (def real (var auto \
          (cond ((and (not (null (@:@ first token-str)))
                      (= 0 (strcmp (@:@ first token-str) "true")))
                 (std.macros.qq true (uq (uq second))))
                ((null (@:@ forms next-node))
                 (std.macros.qq true
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second)))))
                (true
                 (std.macros.qq (= (@: (uq (uq object)) type)
                                   (uq (uq ffirst)))
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second))))))))
        (and (= 0 (strcmp (@:@ first token-str) "true"))
          (setv otherwise true))
        (if (null current)
            (do (setv holder real)
                (setv current real))
            (do (setf (:@ current next-node) real)
                (setv current real)))
        (setv forms (@:@ forms next-node)))
      (and (not otherwise)
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (= 0 (@$ found i))
            (do (report-error mc object "case is non-exhaustive")
                (return (nullptr DNode))))))
      (def x (var auto \ (std.macros.qq do (cond (uq (uql holder))))))
      (return x))))))
)
