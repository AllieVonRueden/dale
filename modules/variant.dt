#|
@module variant

Provides `def-variant`, which allows for defining variants, also known
as sum types or tagged unions.  Variant definition introduces the
following bindings:

   * a struct type for the variant;
   * a struct type for each of the variant's potential types;
   * constructors for each of the potential types, which take as their
     arguments the members for that potential type in definition
     order (if any);
   * a `case` form, which allows for executing a statement based on
     the underlying type of a particular variant.

For example:

        (def-variant Direction (North South East West))

        (def main (fn extern-c int (void)
          (let ((direction Direction (North)))
            (case direction
              (North (printf "Direction is north\n"))
              (true  (printf "Direction is not north\n"))))
          0))

yields:

        Direction is north

With parameters for the potential types:

        (def-variant Number ((Int    ((a int)))
                             (Float  ((a float)))
                             (Double ((a double)))))

        (def main (fn extern-c int (void)
          (let ((ni Number (Int 1))
                (nf Number (Float 2.0))
                (nd Number (Double (cast 3.0 double)))
                (na (array-of 3 Number) (array ni nf nd)))
            (for (i \ 0) (< i 3) (incv i)
              (let ((nc Number (@$ na i)))
                (case nc
                  (Int    (printf "Number is int (%d)\n"    (@:@ nc a)))
                  (Float  (printf "Number is float (%f)\n"  (@:@ nc a)))
                  (Double (printf "Number is double (%f)\n" (@:@ nc a)))))))
          0))

yields:

	Number is int (1)
	Number is float (2.000000)
	Number is double (3.000000)

|#
(module variant (attr cto))

(import cstdio)
(import stdlib)

(using-namespace std.macros

(def prefix-token-node (fn extern (p DNode) ((mc (p MContext))
                                             (prefix (p (const char)))
                                             (node (p DNode)))
  (def buf (var auto (array-of 255 char)))
  (and (null (@:@ node token-str))
    (return (nullptr DNode)))
  (sprintf buf "%s%s" prefix (@:@ node token-str))
  (return (mnfv mc buf))))

(def create-struct-defs (fn intern (p DNode) ((mc (p MContext))
                                              (enumnode (p DNode))
                                              (instances (p DNode)))
  (let ((holder  \ (nullptr DNode))
        (last    \ (nullptr DNode))
        (current \ (@:@ instances list-node)))
    (while (not (null current))
      (let ((has-args \ (not (null (@:@ current list-node))))
            (name     \ (if has-args (@:@ current list-node) current))
            (args     \ (if has-args
                            (@:' current list-node next-node list-node)
                            (qq void)))
            (struct-def \ (if has-args
                              (qq def (uq name)
                                (struct extern ((type (uq enumnode))
                                                (uql args))))
                              (qq def (uq name)
                                (struct extern ((type (uq enumnode))))))))
        (setv current (@:@ current next-node))
        (if (null holder)
            (setv holder struct-def)
            (setf (:@ last next-node) struct-def))
        (setv last struct-def)))
    (return (qq do (uql holder))))))

(def create-setf-forms (fn intern (p DNode) ((mc (p MContext))
                                             (args (p DNode)))
  (let ((holder  \ (nullptr DNode))
        (last    \ (nullptr DNode))
        (current \ (@:@ args list-node)))
    (while (not (null current))
      (let ((name \ (@:@ current list-node)))
        (and (null name)
          (do (report-error mc current "expected list for variant member")
              (return (nullptr DNode))))
        (let ((type \ (@:@ name next-node)))
          (and (null type)
            (do (report-error mc current "expected type for variant member")
                (return (nullptr DNode))))
          (let ((argset \ (qq setf (: my-variant (uq name)) (uq name))))
          (setv current (@:@ current next-node))
          (if (null holder)
              (setv holder argset)
              (setf (:@ last next-node) argset))
          (setv last argset)))))
    (return (qq do (uql holder))))))

(def create-constructors (fn intern (p DNode) ((mc (p MContext))
                                               (name (p DNode))
                                               (instances (p DNode)))
  (let ((holder  \ (nullptr DNode))
        (last    \ (nullptr DNode))
        (current \ (@:@ instances list-node)))
    (while (not (null current))
      (let ((has-args \ (not (null (@:@ current list-node))))
            (cname    \ (if has-args (@:@ current list-node) current))
            (args     \ (if has-args
                            (@:' current list-node next-node)
                            (qq void)))
            (setfs    \ (if has-args
                            (create-setf-forms mc args)
                            (qq do 0)))
            (ename    \ (prefix-token-node mc "_" cname))
            (constructor \
              (qq def (uq cname) (fn extern (retval (uq name)) (uq args)
                (def my-variant (var auto (uq cname)))
                (setf (: my-variant type) (uq ename))
                (uq setfs)
                (memcpy (cast retval (p void))
                        (cast (# my-variant) (p void))
                        (sizeof my-variant))
                (return)))))
        (setv current (@:@ current next-node))
        (if (null holder)
            (setv holder constructor)
            (setf (:@ last next-node) constructor))
        (setv last constructor)))
    (def mholder (var auto (p DNode) (qq do (uql holder))))
    (return mholder))))

(def create-convert-fn (fn intern (p DNode) ((mc (p MContext))
                                             (enumnode (p DNode))
                                             (instances (p DNode)))
  (let ((holder  \ (nullptr DNode))
        (last    \ (nullptr DNode))
        (current \ (@:@ instances list-node)))
    (while (not (null current))
      (let ((has-args \ (not (null (@:@ current list-node))))
            (cname    \ (if has-args (@:@ current list-node) current))
            (qname    \ (std.macros.copy-qstr mc cname false))
            (pname    \ (prefix-token-node mc "_" cname))
            (cel      \ (qq (= 0 (strcmp str (uq qname))) (uq pname))))
        (setv current (@:@ current next-node))
        (if (null holder)
            (setv holder cel)
            (setf (:@ last next-node) cel))
        (setv last cel)))
    (setf (:@ last next-node)
      (qq true (cast -1 (const (uq enumnode)))))
    (qq do
      (def _Convert (fn intern (uq enumnode) ((str (p (const char))))
        (def res (var auto \ (cond (uql holder))))
        res))))))

(def create-enum-elements (fn intern (p DNode) ((mc (p MContext))
                                                (instances (p DNode)))
  (let ((holder  \ (nullptr DNode))
        (last    \ (nullptr DNode))
        (current \ (@:@ instances list-node)))
    (while (not (null current))
      (let ((has-args \ (not (null (@:@ current list-node))))
            (cname    \ (if has-args (@:@ current list-node) current))
            (pname    \ (prefix-token-node mc "_" cname)))
        (setv current (@:@ current next-node))
        (setf (:@ pname next-node) (nullptr DNode))
        (if (null holder)
            (setv holder pname)
            (setf (:@ last next-node) pname))
        (setv last pname)))
    (return (qq (uql holder))))))

(def create-sizes-and-alignments (fn intern (p DNode) ((mc (p MContext))
                                                       (instances (p
                                                       DNode)))
  (let ((holder  \ (nullptr DNode))
        (last    \ (nullptr DNode))
        (current \ (@:@ instances list-node))
        (num     \ 0))
    (while (not (null current))
      (let ((has-args \ (not (null (@:@ current list-node))))
            (cname    \ (if has-args (@:@ current list-node) current))
            (cnode    \ (mnfv mc num))
            (mnode    \ (qq do
                          (setf ($ sizes (uq cnode))
                                (sizeof (uq cname)))
                          (setf ($ alignments (uq cnode))
                                (alignmentof (uq cname))))))
        (setv current (@:@ current next-node))
        (setf (:@ mnode next-node) (nullptr DNode))
        (incv num)
        (if (null holder)
            (setv holder mnode)
            (setf (:@ last next-node) mnode))
        (setv last mnode)))
    (return (qq do (uql holder))))))

#|
@macro def-variant

@param name         The name of the new variant.
@param instances    The type definitions for the variant.
|#
(def def-variant (macro extern (name instances)
  (def enumnode (var auto \ (prefix-token-node mc "_Enum" name)))
  (and (null enumnode)
    (do (report-error mc name "atom required for variant name")
        (return (nullptr DNode))))

  (def lookupnode (var auto \ (prefix-token-node mc "_Lookup" name)))

  (def struct-defs (var auto (p DNode)
                             (create-struct-defs mc enumnode instances)))
  (def constructors (var auto (p DNode)
                              (create-constructors mc name instances)))

  (def convert-fn (var auto (p DNode)
                            (create-convert-fn mc enumnode instances)))
  (def lc (var auto \ (mnfv mc (list-count instances))))

  (def enum-elements (var auto (p DNode) (create-enum-elements mc
                                            instances)))

  (def sizes-and-alignments
    (var auto (p DNode) (create-sizes-and-alignments
                            mc instances)))

  (qq do
    (def (uq enumnode) (enum extern int (uq enum-elements)))
    (uq struct-defs)

    (def mm
      (macro intern (void)
        (def sizes (var auto (array-of (uq lc) size)))
        (def alignments (var auto (array-of (uq lc) size)))
        (uq sizes-and-alignments)
        (def maxsize (var auto size 0))
        (def maxalignment (var auto size 0))
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (> (@$ sizes i) maxsize)
            (setv maxsize (@$ sizes i)))
          (and (> (@$ alignments i) maxalignment)
            (setv maxalignment (@$ alignments i))))
        (def remsize (var auto size (- maxsize (sizeof (uq enumnode)))))
        (setv remsize (+ remsize (% maxsize maxalignment)))
        (def remsizen (var auto (p DNode) (std.macros.mnfv mc (cast remsize int))))
        (std.macros.qq def (uq name)
          (struct extern ((type (uq enumnode))
                          (_unused (array-of (uq (uq remsizen)) uint8)))))))
    (mm)

    (uq constructors)
    (uq convert-fn)
    (def case (macro extern ((object (uq name)) ...)
      (and (null (@:@ object token-str))
        (do (report-error mc object "case expression must be variable name")
            (return (nullptr DNode))))

      (def found (var auto (array-of (uq lc) int)))
      (memset (cast found (p void)) 0 (uq lc))

        (for (i \ 0) (< i (uq lc)) (incv i)
          (setf ($ found i) 0))

      (def otherwise (var auto bool false))

      (def arg-count (var auto \ (arg-count mc)))
      (setv arg-count (- arg-count 1))
      (def arglist (var auto va-list))
      (va-start (cast (# arglist) (p void)))
      (def forms (var auto \ (std.macros.get-varargs-list mc arg-count (# arglist))))
      (va-end (cast (# arglist) (p void)))

      (def holder (var auto (p DNode) (nullptr DNode)))
      (def current (var auto (p DNode) (nullptr DNode)))
      (while (not (null forms))
        (def first (var auto \ (@:@ forms list-node)))
        (def ffirst (var auto \ (prefix-token-node mc "_" first)))
        (def second (var auto \ (@:@ first next-node)))

        (and (not (= 0 (strcmp (@:@ first token-str) "true")))
          (do (def ev (var auto \ (_Convert (@:@ first token-str))))
              (if (= (cast ev int) -1)
                  (do (report-error mc first "invalid variant type")
                      (return (nullptr DNode)))
                  (setf ($ found ev) 1))))

        (def real (var auto \
          (cond ((and (not (null (@:@ first token-str)))
                      (= 0 (strcmp (@:@ first token-str) "true")))
                 (std.macros.qq true (uq (uq second))))
                ((null (@:@ forms next-node))
                 (std.macros.qq true
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second)))))
                (true
                 (std.macros.qq (= (@: (uq (uq object)) type)
                                   (uq (uq ffirst)))
                                (let ((ptr \ (cast (# (uq (uq object))) (p void)))
                                      ((uq (uq object))
                                       (p (uq (uq first)))
                                       (cast ptr (p (uq (uq first))))))
                                  (uq (uq second))))))))
        (and (= 0 (strcmp (@:@ first token-str) "true"))
          (setv otherwise true))
        (if (null current)
            (do (setv holder real)
                (setv current real))
            (do (setf (:@ current next-node) real)
                (setv current real)))
        (setv forms (@:@ forms next-node)))
      (and (not otherwise)
        (for (i \ 0) (< i (uq lc)) (incv i)
          (and (= 0 (@$ found i))
            (do (report-error mc object "case is non-exhaustive")
                (return (nullptr DNode))))))
      (def x (var auto \ (std.macros.qq do (cond (uq (uql holder))))))
      (return x))))))
)
