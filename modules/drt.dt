#|
@module drt

'drt' is an abbreviation of 'Dale runtime'. The terminology is not
strictly accurate: it only contains those functions added by the
compiler, implicitly, to every program. In turn, the libraries
generated by way of compiling this module are used by the compiler
implicitly where necessary.
|#
(module drt)

(def DNode
  (struct extern ((is-list int)
                  (token-str (p char))
                  (list-node (p DNode))
                  (next-node (p DNode))
                  (begin-line int)
                  (begin-column int)
                  (end-line int)
                  (end-column int)
                  (macro-begin-line int)
                  (macro-begin-column int)
                  (macro-end-line int)
                  (macro-end-column int)
                  (filename (p char)))))

(def PoolNode
  (struct extern ((value (p void))
                  (next-node (p PoolNode))
                  (last-node (p PoolNode)))))

(def MContext
  (struct opaque ((arg-count int)
                  (pool-node (p PoolNode))
                  (generator (p void)))))

(def malloc (fn extern-c (p void) ((n size))))
(def free (fn extern-c void ((ptr (p void)))))
(def not (fn _extern-weak bool ((a bool)) (if a false true)))
(def memcpy (fn extern-c (p void) ((a (p void)) (b (p void)) (c size))))
(def pool-malloc
  (fn _extern-weak (p void) ((mc (p MContext)) (n size))
    (def pool-node (var auto \ (@:@ mc pool-node)))
    (def ln (var auto (p PoolNode) (@ (: (@ pool-node) last-node))))
    (if (null ln)
        (do (setf (: (@ pool-node) last-node) pool-node)
            (setv ln (@ (: (@ pool-node) last-node)))
            0)
        0)

    (def new-node    (var auto (p PoolNode)
                               (cast (malloc (sizeof PoolNode))
                                     (p PoolNode))))
    (def new-pointer (var auto (p void)     (malloc n)))

    (setf (: (@ new-node) value)     (cast 0 (p void)))
    (setf (: (@ new-node) next-node) (cast 0 (p PoolNode)))

    (setf (: (@ ln) value)     new-pointer)
    (setf (: (@ ln) next-node) new-node)
    (setf (: (@ pool-node) last-node) new-node)

    (return new-pointer)))

(def pool-free_
  (fn _extern-weak void ((pool-node (p PoolNode)))
    (if (not (null (@ (: (@ pool-node) value))))
        (do (free (@:@ pool-node value)) 0)
        0)
    (if (not (null (@:@ pool-node next-node)))
        (do (pool-free_ (@:@ pool-node next-node)) 0)
        0)
    (free (cast pool-node (p void)))
    (return)))

(def pool-free
  (fn _extern-weak void ((mc (p MContext)))
    (pool-free_ (@:@ mc pool-node))))

(def arg-count
  (fn _extern-weak int ((mc (p MContext)))
    (@:@ mc arg-count)))

; See https://github.com/ARM-software/abi-aa/releases/download/2021Q1/aapcs64.pdf.
(def va-list-aarch64
  (struct extern ((stack (p void))
                  (gr-top (p void))
                  (vr-top (p void))
                  (gr-offs int)
                  (vr-offs int))))

(def va-arg-aarch64
  (fn _extern-weak (p void) ((arglistv (p void))
                             (typenum int)
                             (alignment size)
                             (size size)
                             (buffer (p void))
                             (elements int))
    (def arglist (var auto (p va-list-aarch64)
                           (cast arglistv (p va-list-aarch64))))
    (def offs (var auto int 0))
    (def nreg (var auto int 0))
    (if (= typenum 0)
        (do (setv offs (@:@ arglist gr-offs))
            (if (>= offs 0)
                (goto on-stack)
                0)
            (if (> alignment (cast 8 size))
                (setv offs (& (+ offs 5) -16))
                0)
            (setv nreg
                  (cast (/ (+ size (cast 7 size)) (cast 8 size))
                        int))
            (setf (:@ arglist gr-offs)
                  (+ offs (* nreg 8)))
            (if (> (@:@ arglist gr-offs) 0)
                (goto on-stack)
                0)
            (def gr-top (var auto intptr (cast (@:@ arglist gr-top) intptr)))
            (setv gr-top (if (< offs 0)
                             (- gr-top (cast (* offs -1) intptr))
                             (+ gr-top (cast offs        intptr))))
            (return (cast gr-top (p void))))
        0)
    (if (= typenum 1)
        (do (setv offs (@:@ arglist vr-offs))
            (if (>= offs 0)
                (goto on-stack)
                0)
            (def sizeof-ftype (var auto size (sizeof double)))
            (setv nreg (cast (/ size sizeof-ftype) int))
            (setf (:@ arglist vr-offs)
                  (+ offs (* nreg 16)))
            (if (> (@:@ arglist vr-offs) 0)
                (goto on-stack)
                0)
            (def i (var auto int 0))
            (def buf-ptr (var auto intptr (cast buffer intptr)))
            (def vr-top (var auto intptr (cast (@:@ arglist vr-top) intptr)))
            (label start-loop)
              (setf (cast (+ buf-ptr (cast (* i (cast sizeof-ftype int)) intptr))
                          (p double))
                    (@ (cast (if (< offs 0)
                                 (- vr-top (cast (* offs -1) intptr))
                                 (+ vr-top (cast offs        intptr)))
                             (p double))))
              (setv i (+ i 1))
              (if (>= i nreg)
                  (goto end-loop)
                  0)
              (setv offs (+ offs 16))
              (goto start-loop)

            (label end-loop)
              (return (nullptr void)))
        0)
    (if (= typenum 2)
        (do (setv offs (@:@ arglist vr-offs))
            (if (>= offs 0)
                (goto on-stack)
                0)
            (setv nreg
                  (cast (/ (+ size (cast 15 size)) (cast 16 size))
                        int))
            (setf (:@ arglist vr-offs)
                  (+ offs (* nreg 16)))
            (if (> (@:@ arglist vr-offs) 0)
                (goto on-stack)
                0)

            (def vr-top (var auto intptr (cast (@:@ arglist vr-top) intptr)))
            (setv vr-top (if (< offs 0)
                             (- vr-top (cast (* offs -1) intptr))
                             (+ vr-top (cast offs        intptr))))
            (return (cast vr-top (p void))))
        0)

    (label on-stack)
      (def arg (var auto int64 (cast (@:@ arglist stack) int64)))
      (if (> alignment (cast 8 size))
          (setv arg (& (+ arg (cast 15 int64)) (cast -16 int64)))
          0)
      (setf (:@ arglist stack)
            (cast (& (+ (+ arg (cast size int64)) (cast 7 int64)) (cast -8 int64))
                  (p void)))
      (return (cast arg (p void)))))

; See https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms.
; todo: this doesn't cover every case (e.g. some struct definitions),
; but the common cases appear to be fine.
(def va-list-arm64-apple
  (struct extern ((stack (p void)))))

(def va-arg-arm64-apple
  (fn _extern-weak (p void) ((arglistv (p void))
                             (alignment size)
                             (size size))
    (def arglist (var auto (p va-list-arm64-apple)
                           (cast arglistv (p va-list-arm64-apple))))
    (def arg (var auto int64 (cast (@:@ arglist stack) int64)))
    (if (> alignment (cast 8 size))
        (setv arg (& (+ arg (cast 15 int64)) (cast -16 int64)))
        0)
    (setf (:@ arglist stack)
          (cast (& (+ (+ arg (cast size int64)) (cast 7 int64)) (cast -8 int64))
                (p void)))
    (return (cast arg (p void)))))
