{"name":"Dale","tagline":"Lisp-flavoured C","body":"## Dale\r\n\r\n[![Build Status](https://travis-ci.org/tomhrr/dale.png)](https://travis-ci.org/tomhrr/dale)\r\n\r\nDale is a system (no GC) programming language that uses S-expressions\r\nfor syntax and supports syntactic macros. The basic language is\r\nsimilar to C, with the following additional features:\r\n\r\n  * local type deduction;\r\n  * overloaded functions;\r\n  * anonymous functions;\r\n  * function structs;\r\n  * reference parameters;\r\n  * initialisers and destructors;\r\n  * namespaces;\r\n  * modules;\r\n  * concepts; and\r\n  * compiler introspection.\r\n\r\n### Supported systems\r\n\r\nThis should be usable on most Linux/OS X/BSD systems where LLVM is\r\nable to be built.  It has been tested on the following:\r\n\r\n  * Debian 7.8, 8.0 (x86 and x86-64)\r\n  * OS X 10.9.2\r\n  * FreeBSD 10.0 (x86-64)\r\n\r\n### Documentation\r\n\r\n[Index](./doc/index.md)  \r\n[As single page](./doc/all.md)\r\n\r\n### Install\r\n\r\n#### Dependencies\r\n\r\n  * LLVM (3.2-3.5)\r\n  * libffi\r\n\r\n#### Out-of-tree (recommended)\r\n\r\n    mkdir ../build\r\n    cd ../build\r\n    cmake ../dale\r\n    make\r\n    make tests\r\n    make install\r\n\r\n#### In-tree\r\n\r\n    cmake .\r\n    make\r\n    make tests\r\n    make install\r\n\r\n### Examples\r\n\r\n**hello-world**\r\n\r\n```\r\n(import cstdio)\r\n\r\n(def main (fn extern-c int (void)\r\n  (printf \"hello, world\\n\")))\r\n```\r\n```\r\n> hello, world\r\n```\r\n\r\n**hello-name**\r\n\r\n```\r\n(import cstdio)\r\n\r\n(def main (fn extern-c int (void)\r\n  (def name (var auto (p (const char)) \"name\"))\r\n  (printf \"hello, %s\\n\" name)))\r\n```\r\n```\r\n> hello, name\r\n```\r\n\r\n**type-deduction**\r\n\r\n```\r\n(import cstdio)\r\n(import stdlib)\r\n\r\n(def main (fn extern-c int (void)\r\n  (let ((a \\ 1)\r\n        (b \\ 2))\r\n    (printf \"%d\\n\" (+ a b)))))\r\n```\r\n```\r\n> 3\r\n```\r\n\r\n**overloading**\r\n\r\n```\r\n(import cstdio)\r\n(import cstdlib)\r\n\r\n(def Point (struct intern ((x int) (y int))))\r\n\r\n(def + (fn intern Point ((a Point) (b Point))\r\n  (let ((r Point ((x (+ (@: a x) (@: b x)))\r\n                  (y (+ (@: a y) (@: b y))))))\r\n    (return r))))\r\n\r\n(def main (fn extern-c int (void)\r\n  (let ((a Point ((x 1) (y 2)))\r\n        (b Point ((x 3) (y 4)))\r\n        (c Point (+ a b)))\r\n    (printf \"%d %d\\n\" (@: c x) (@: c y)))))\r\n```\r\n```\r\n> 4 6\r\n```\r\n\r\n**anonymous-functions**\r\n\r\n```\r\n(import cstdio)\r\n(import stdlib)\r\n\r\n(def main (fn extern-c int (void)\r\n  (let ((anon-fn \\ (fn int ((n int)) (* 2 n))))\r\n    (printf \"%d\\n\" (anon-fn 5)))))\r\n```\r\n```\r\n> 10\r\n```\r\n\r\n**macros**\r\n\r\n```\r\n(import cstdio)\r\n(import stdlib)\r\n(import macros)\r\n\r\n(using-namespace std.macros\r\n  (def unless (macro intern (condition statement)\r\n    (qq do\r\n      (and (not (uq condition))\r\n           (do (uq statement) true)))))\r\n\r\n  (def main (fn extern-c int (void)\r\n    (unless (= 1 2)\r\n      (printf \"1 does not equal 2\\n\"))\r\n    (return 0))))\r\n```\r\n```\r\n> 1 does not equal 2\r\n```\r\n\r\n**typed-macros**\r\n\r\n```\r\n(import cstdio)\r\n(import macros)\r\n\r\n(using-namespace std.macros\r\n  (def + (macro intern ((a int) (b int) (c int))\r\n    (qq do (+ (uq a) (+ (uq b) (uq c))))))\r\n\r\n  (def main (fn extern-c int (void)\r\n    (printf \"%d\\n\" (+ 1 2 3)))))\r\n```\r\n```\r\n> 6\r\n```\r\n\r\n**introspection**\r\n\r\n```\r\n(import introspection)\r\n(import macros)\r\n\r\n(def Point (struct intern ((x int) (y int))))\r\n\r\n(using-namespace std.macros\r\n  (def show-struct-details (macro intern (st)\r\n     (let ((name  \\ (@:@ st token-str))\r\n           (count \\ (struct-member-count mc st)))\r\n       (printf \"Struct: %s\\n\"       name)\r\n       (printf \"Member count: %d\\n\" count)\r\n       (let ((i \\ 0))\r\n         (for true (< i count) (incv i)\r\n           (printf \"Member %d: %s\\n\" (+ i 1) (struct-member-name mc st i))))\r\n       (nullptr DNode))))\r\n\r\n  (def main (fn extern-c int (void)\r\n    (show-struct-details Point)\r\n    0)))\r\n```\r\n```\r\n> Struct: Point\r\n> Member count: 2\r\n> Member 1: x\r\n> Member 2: y\r\n```\r\n\r\n**error-reporting**\r\n\r\n```\r\n(import introspection)\r\n(import macros)\r\n\r\n(using-namespace std.macros\r\n  (def assert-is-struct (macro intern (st)\r\n    (let ((count \\ (struct-member-count mc st)))\r\n      (and (= -1 count)\r\n           (do (report-error mc st \"struct type does not exist\")\r\n               true))\r\n      (return (nullptr DNode)))))\r\n\r\n  (def main (fn extern-c int (void)\r\n    (assert-is-struct Point)\r\n    0)))\r\n```\r\n```\r\n> ./error-reporting.dt:13:23: error: struct type does not exist (see macro at 13:5)\r\n```\r\n\r\n**derivations**\r\n\r\n```\r\n(import derivations)\r\n\r\n(def Point (struct intern ((x int) (y int))))\r\n\r\n(std.concepts.implement Struct Point)\r\n(std.concepts.instantiate relations Point)\r\n\r\n(def main (fn extern-c int (void)\r\n  (let ((p1 Point ((x 1) (y 2)))\r\n        (p2 Point ((x 3) (y 4))))\r\n    (and (!= p1 p2)\r\n         (do (printf \"p1 and p2 are not equal\\n\") true))\r\n    (and (<= p1 p2)\r\n         (do (printf \"p1 is less than or equal to p2\\n\") true))\r\n    (and (> p2 p1)\r\n         (do (printf \"p2 is more than p1\\n\") true))\r\n    0)))\r\n```\r\n```\r\n> p1 and p2 are not equal\r\n> p1 is less than or equal to p2\r\n> p2 is more than p1\r\n```\r\n\r\n**containers**\r\n\r\n```\r\n(import vector)\r\n(import array)\r\n(import algorithms)\r\n(import cstdio)\r\n\r\n(using-namespace std.concepts\r\n  (instantiate Vector int)\r\n  (instantiate Array int 10)\r\n  (instantiate copy (Iterator (Vector int))\r\n                    (Iterator (Array int 10))))\r\n\r\n(def main (fn extern-c int (void)\r\n  (let ((vec (Vector int))\r\n        (arr (Array int 10))\r\n        (i int))\r\n    (for (setv i 0) (< i 10) (incv i)\r\n      (push-back vec i))\r\n    (copy (begin vec) (end vec) (begin arr))\r\n    (let ((b \\ (begin arr))\r\n          (e \\ (end arr)))\r\n      (for true (!= b e) (setv b (successor b))\r\n        (printf \"%d \" (@source b))))\r\n    (printf \"\\n\")\r\n    0)))\r\n```\r\n```\r\n> 0 1 2 3 4 5 6 7 8 9 \r\n```\r\n\r\n### Bugs/problems/suggestions\r\n\r\nPlease report to the [GitHub issue tracker](https://github.com/tomhrr/dale/issues).\r\n\r\n### Licence\r\n\r\nSee LICENCE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}